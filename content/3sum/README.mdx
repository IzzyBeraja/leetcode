---
title: 3Sum
problemNumber: 15
completionDate: 02/25/2024
difficulty: Medium
personalDifficulty: ⭐️⭐️⭐️⭐️
topics: [array, two-pointers, sorting]
url: https://leetcode.com/problems/3sum/
---

# Prompt

Given an integer array `nums`, return all the triplets
`[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and
`nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

Example 1:

> Input: nums = [-1,0,1,2,-1,-4]\
> Output: [[-1,-1,2],[-1,0,1]]

Example 2:

> Input: nums = [0,1,1]\
> Output: []

Example 3:

> Input: nums = [0,0,0]\
> Output: [[0,0,0]]

Constraints:

- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

# Solution

> Time Complexity: `O(n^2)`\
> Space Complexity: `O(n)`

This problem requires that we find a unique set of triplets in an array that sum
to `0`. We are provided an array of integers that are not sorted and may contain
duplicates. The first step is to sort the array which will allow us to use a
two-pointer approach repeatedly to find the unique triplets. If the sum of the
values is below our sum of `0`, we advance the left pointer to increase the sum.
If the sum is above our sum of `0`, we decrease the right pointer to decrease
the sum. If the sum is equal to `0`, we have found a solution and can add it to
our result.

The trickiest part of this problem is recognizing how to identify duplicate
triplet values. We want to skip over values that we have already seen which can
be accomplished by looping over values that are identical to the value we are
currently on. Since we sorted the array, we know that duplicate values are next
to each other. This means that as long as the current value is the same as the
previous, we can keep advancing. This is not only true for the first index, but
the two pointers as well. If we find a solution, this means that the current
left and right pointers have found their matching values, so we can advance both
pointers to the next unique value at the same time.

One might think to remove duplicates from the array, but this can actually cause
some of the solutions to be missed. For example, if we have an array of
`[0, 0, 0, 0]`, we can have a solution of `[[0, 0, 0]]` which would be missed if
we removed duplicates. This makes the problem significantly more difficult. We
also can't quickly check if we have found a solution already by using a set, as
the set does not perform a deep equality check and worse, if it did, it would
make the problem `O(n^3)`.

Although this problem is rated as being of medium level, due to the requirement
of understanding how to avoid duplicate solutions and the unconventional
two-pointer approach of avoiding repeat answers, I would rate this problem as
being of hard difficulty.
